/*

Copyright (c) 2012 Steven Braeger

Permission is hereby granted, free of charge, to any person obtaining a copy of this software
and associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute, 
sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice 
shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

#ifndef GL_HPP_COMMON_H
#define GL_HPP_COMMON_H

%(TYPEDEFS)s

%(API_NAMES)s

#define GLHPP_GL_VERSION                        0x1F02
#define GLHPP_GL_EXTENSIONS			0x1F03
#define GLHPP_GL_NUM_EXTENSIONS                 0x821D

extern const GLubyte* glGetString(GLenum name);
extern void glGetIntegerv(GLenum pname,GLint *params);

typedef struct _version_info_t
{
	unsigned int first;
	unsigned int second;
} version_info;

typedef struct _extension_set_t
{
	const char* extensionstringmemory;
	const char** extensionstringbeginnings;
	size_t num_extensions;
} extension_set;

int glhppCheckExtension(const char* extname);
int glhppCheckVersion(unsigned int vmaj,unsigned int vmin);

void* glhppGetProcAddress(const char* funcname);
void* glhppGetProcAddressExtension(const char* funcname,const char* extname);
void* glhppGetProcAddressVersion(const char* funcname,unsigned int vmaj,unsigned int vmin);

const extension_set* glhppGetExtensions();
const version_info* glhppGetVersion();

typedef void (*_glhpp_error_callback_func)(void* userdata,const char* msgformat,const char* extname,const char* extfunc);
inline void _glhppDefaultError(void* userdata,const char* msgformat,const char* extname,const char* extfunc)
{
	fprintf(msgformat,extname,exfunc);
}

inline void _glhppErrorCallbackBackend(void* userdata,const char* msgformat,const char* extname,const char* extfunc,_glhpp_error_callback_func cbfnew)
{
	static _glhpp_error_callback_func ecb=&_glhppDefaultError;
	static void* ud=userdata;
	if(cbfnew)
	{
		ecb=cbfnew;
		ud=userdata;
	}
	else
	{
		return ecb(ud,msgformat,extname,extfunc);
	}
}

inline void glhppError(sconst char* msgformat,const char* extname,const char* extfunc)
{
	_glhppErrorCallbackBackend(NULL,msgformat,extname,extfunc,NULL);
}
inline void glhppSetError(_glhpp_error_callback_func cbfnew,void* ud)
{
	_glhppErrorCallbackBackend(ud,NULL,NULL,NULL,cbfnew);
}

inline int strptrcmp(const void* a,const void* b)
{
	return strcmp(*(const char**)a,*(const char**)b);
}
static inline version_info _get_version()
{
	const char* vs=(const char*)glGetString(GLHPP_GL_VERSION));
	
	version_info vis;
	vs.first = (int)(vs[0]-'0');
	vs.second= (int)(vs[2]-'0');
	return vis;
}
typedef const GLubyte* (*PFNGLGETSTRINGIPROC_PRIV)(GLenum name, GLuint index);

inline extension_set _get_extensions()
{
	extension_set extlist;
	GLint isversion=glhppCheckVersion(3,0);

	if(isversion)
	{
		GLint extmax;
		char* extstring;
		char* extstringhead=extstring;
		size_t bufsize=0;
		size_t bufbackingsize=0;
		static PFNGLGETSTRINGIPROC_PRIV gsi=(PFNGLGETSTRINGIPROC_PRIV)_prim_GetProcAddress("glGetStringi");
		GLint i;
		glGetIntegerv(GLHPP_GL_NUM_EXTENSIONS,&extmax);
		static const size_t AVG_EXTNAME_BYTES=12;
		bufbackingsize=AVG_EXTNAME_BYTES*extmax; //estimate size to minimize reallocs to approximately 3
		exstring=(char*)malloc(bufbackingsize);
		for(i=0;i<extmax;i++)
		{
			const char* curstringname=(const char*)gsi(GLHPP_GL_EXTENSIONS,i);
			size_t csnl=strlen(curstringname)+1;
			if(exstringhead+csnl >= exstring+backingsize)
			{
				bufbackingsize<<=1;
				extstring=(char)realloc(extstring,bufbackingsize);
			}
			strncpy(extstringhead,curstringname,csnl);
			extstringhead[csnl-1]=' ';
			extstringhead+=csnl;
		}
		extlist.num_extensions=extmax;
		extlist.extensionstringmemory=exstring;
		memset(extstringhead,extstring+bufbackingsize,0);
	}
	else
	{
		const char* extother=(const char*)glGetString(GLHPP_GL_EXTENSIONS);
		extlist.extensionstringmemory=(char*)malloc(strlen(extother));
		strcpy(extlist.extensionstringmemory,extother);
		for(char* pch=strchr(extlist.extensionstringmemory,' ');pch!=NULL;pch=strchr(pch+1,' '))
		{
			extlist.num_extensions++;
		}
	}
	char** extindices=(char**)malloc(exlist.num_extensions*sizeof(const char*));
	char** extindiceshead=extindices
	for(char* pch=strtok(extlist.extensionstringmemory," \n\t");pch!=NULL;pch=strchr(extlist.extensionstringmemory," \n\t"))
	{
		*(extindiceshead++)=pch;
	}
	//binary sort the extindices for searching later
	qsort(extindices,exlist.num_extensions,sizeof(const char*),strptrcmp);
	extlist.extensionstringbeginnings=extindices;
	return extlist;
}
inline int _es_contains(const char* namecheck)
{
	static const extension_set* es=get_extensions();
	return bsearch(&namecheck,es->extensionstringbeginnings,es->num_extensions,sizeof(const char*),strptrcmp)!=NULL;
}

inline int glhppCheckExtension(const char* extname)
{
	return _es_contains(extname);
}

inline const version_info* glhppGetVersion()
{
	static version_info v=_get_version();
	return &v;
}
inline const extension_set* glhppGetExtensions()
{
	static extension_set extarray=_get_extensions();
	return &extarray;
}
inline int glhppCheckVersion(unsigned int vmaj,unsigned int vmin)
{
	static const version_info* v=glhppGetVersion();
	return (vmaj*10+vmin) <= (v->first*10+v->second);
}
inline void* glhppGetProcAddress(const char* funcname)
{
	void* fptr=_prim_GetProcAddress(funcname);
	if(fptr)
		return fptr;
	else
	{
		glhppError("Error, %s was not found in this context %s\n",funcname,"",NULL);
	}
}

inline void* glhppGetProcAddressExtension(const char* frequest,const char* extext)
{
	if(glhppCheckExtension(extext))
	{
		void* fptr=_prim_GetProcAddress(frequest);
		if(fptr)
			return fptr;
		else
		{
			glhppError("Error, %s was not found in this context even though %s is supported\n",funcname,extext,NULL);
		}
	}
	else
	{	
		glhppError("Error, %s was not found in this context because %s is not supported\n",funcname,extext,NULL);
		std::ostringstream oss;
		oss << "Error, " << extext << " is not supported, so " << frequest << " was not found in the context.";
		throw ProcedureNotFound(oss.str());
	}
}
inline void* glhppGetProcAddressVersion(const char* frequest,unsigned int vmaj,unsigned int vmin)
{
	char vstring[]="X.X"
	vstring[0]=(char)('0'+vmaj);
	vstring[2]=(char)('0'+vmin);
	if(glhppCheckVersion(vmaj,vmin))
	{
		void* fptr=_prim_GetProcAddress(frequest);
		if(fptr)
			return fptr;
		else
		{
			glhppError("Error, %s was not found in this context even though GL version %s\n",frequest,vstring,NULL);
		}
	}
	else
	{
		glhppError("Error, %s was not found in this context because GL version %s is not supported by this context\n",frequest,vstring,NULL);
	}
}


#endif
